+++
title="Are you a Programmer?"
date=2011-10-20
[taxonomies]
tags=["culture", "dev"]
+++

My geography teacher once told the story of her first lecture at University.
As an introduction, her professor asked the class to draw
a map of Germany without any help and as accurate as possible. To her surprise, she was not
able to fill the map with much detail. Even the shape of the country was a bit vague.

She had seen thousands of images of Germany (her mother country) but
wasn't able to reproduce it from her blurry memory. She would have to look it up.

Doesn't this sound familiar? We rely on machines to manage large portions
of our knowledge. There's [hard work](@/2011/on-hard-work/index.md) involved to learn something by heart.

Here is a similar test for programmers:

> Using a programming language of your choice, write a correct sorting
> algorithm with an average runtime complexity of O(n\*log n) (Heapsort,
> Quicksort, Bucketsort, you name it) on a piece of paper without the help of any
> external tools.

And by _correct_ I mean it must be free of bugs without any modifications when you type it in.

You would be surprised by the large percentage of professional software
engineers who [can't pull this off](https://blog.codinghorror.com/why-cant-programmers-program/).

Some might argue that knowledge about details of programming language
syntax is unimportant: "Why learn all the little nitpicks when you know
how to use a search engine? Why start with a clean slate when you can easily
copy, paste and modify an example from a tutorial?
Every few years/months I have to completely relearn the syntax for a different language anyway."

But that is a myth. If you know only
one programming language **really** well - even if it is something
outdated like Fortran or COBOL - you could easily earn a fortune with
that knowledge. Suppose you started with C in 1975. You could still
use the same syntax today - almost four decades later.
Same for text editors. Emacs and Vim are both decades
old. They are battle-hardened. I don't care which one you prefer, but you
will spend a large part of your life with your tools so invest the time to master them.

As a side note, it appears that very few people strive for perfection in anything they do.
They happily settle for "good enough". This can have many different reasons, and I'm not
blaming anybody for not doing his homework but maybe I'm not alone with
that observation.

If you don't know how to use your tools without a manual, you are a lousy craftsman.
If you need a dictionary to write a simple letter, you will have a hard
time becoming a writer because it would already be challenging for you to form elegant, fluent
sentences &mdash; let alone engaging and original stories.
I don't want to read these books.

What makes a programmer?

- She has at least one programming language she knows inside out.
- She can implement standard algorithms (i.e. for sorting, searching)
  and data-structures (i.e. trees, linked lists) which are robust and
  reasonably fast on the fly.
- She has at least a basic understanding of complexity theory and
  programming concepts like recursion and pointers.

But, to be a good programmer, you should

- Be able to code in at least two fundamentally different programming
  paradigms (i.e. declarative, functional).
- Have experience with big software architectures.
- Be familiar with your programming environment like the operating system and a sophisticated text editor of your choice. Preferably one, that is
  easily extendable.

And that is just the tip of the iceberg.
"There's too much to learn!", I hear some of you say.
Start slowly.
You need only three commands to start with Vim: `i`, `ESC`, `:wq`.
That's enough for day one.

I realize that most of these essentials won't be taught during lectures.
You have to learn a vast portion on your own.
But let's face it: If you don't know this stuff, you are _not_ a programmer, you're a freshman.
