+++
title="Tools"
date=2011-10-30
[taxonomies]
tags=["dev"]
+++

For as long as I can think, religious flamewars have infected computer science.

Having arguments about technical topics can be healthy, but flamewars are not. I'm sick of it.
I'm fed up with people telling me that their work environment is oh-so better,
faster and so on. That's fine, but it doesn't matter. Your equipment only plays a supporting role. You don't even need
a computer to do programming. Donald Knuth wrote algorithms on a
notepad. Alan Turing wrote the first chess computer on a piece of
paper. And it worked. Beat that!

For an average user, the next best system is probably good enough. Just a few bucks and you get an excellent piece of hardware which is completely sufficient to surf the web, chat, archive photos, write documents, listen to music and watch movies. You can do that with a Pentium IV, 256 MB RAM and any recent Operating System (you will likely get that one for free). Heck, you can use your old Commodore for most of that. Computers have been mature and reliable enough to do all that for ages. There's no need to upgrade your system for Farmville, just like there's no reason to buy a new car if the old one works perfectly fine. When it comes to software, many of us still use Office 2000 or Photoshop 8 or VisiCalc without feeling the urge to upgrade.

Professionals find themselves in a similar situation. Well, maybe we invest a bit more money, but still, our hardware is incredibly cheap compared to our salary (hopefully). Nothing is perfect, but most of the time _it's good enough_. That compiler you were using a decade ago? Still does the job. We are still using slightly modified descendants of programming languages from computing stone-age. Even if you're doing numerical computing for NASA, your primary work environment is a black box running a text editor or an IDE.

I don't care what _you_ are using to get things done. Find an environment that suits _your_ needs and be happy with it. Maybe you use Emacs on a Lemote Yeelong netbook (hello Richard Stallman) or Vim on your workstation. It's the same thing: A text editor running on a piece of metal.
You're not a worse programmer for using Nano, ed or TextMate. Notepad works just fine, too. It loads files, saves files and lets you edit them in between. That's a hell lot more functionality than Bill Gates and Paul Allen had when they wrote a BASIC interpreter for the Altair. If you find something you're happy with, just stick with it but don't start arguing. It isn't worth your time.

Don't feed the trolls. When it comes to software, don't fall into the old FreeBSD vs. Linux vs. Windows vs. mum cliche. Instead, talk about your code. Let's look at your problem-solving skills. Let's be pragmatic here.

> Talk is cheap. Show me the code. - [Linus Torvalds](https://lkml.org/lkml/2000/8/25/132)

I don't care which programming language you are using. Java? Fine. Visual Basic? Great! Scala, Cobol, PHP, C++? All fine. Write in Assembler or lolcode. Don't moan about the fact that language X is missing feature Y. Write a library or use something different. Stop saying JavaScript is a toy language. It just doesn't fit your needs. Instead, show me your Lisp adventure game. Write an interpreter for Brainfuck. Do something. Move things.

Concerning PHP, [nir wrote on Hacker News](https://news.ycombinator.com/item?id=2282523):

> Any idiot can write a snarky comment about PHP. Very few get to write code that has anywhere near the impact it had.

Will you fall off your chair when I admit that I _like_ the PHP syntax?
OK, it has its rough edges (do we really need the \$ sign?) but what's
more important is how much I can get done with it. PHP was my long time
go-to language for off the hook, one time scripts. It looks a bit ugly
but it runs on any server and comes with an enormous amount of built-in
functionality. It's great for rapid prototyping and gluing things together.
In fact, when you write a piece of software, what you should strive for is to produce _quite good_ software and what you really need to accomplish is _good enough_ software to make your users happy.

Zed A. Shaw puts it quite nicely in the afterword to [Learn Python the hard way](https://learnpythonthehardway.org/)

> I have been programming for a very long time. So long that it is incredibly boring to me. At the time that I wrote this book I knew about 20 programming languages and could learn new ones in about a day to a week depending on how weird they were. Eventually though this just became boring and couldn't hold my interest. What I discovered after this journey of learning was that the languages didn't matter, it was what you did with them. Actually, I always knew that, but I'd get distracted by the languages and forget it periodically. The programming language you learn and use does not matter. Do not get sucked into the religion surrounding programming languages as that will only blind you to their real purpose of being your tool for doing interesting things.

Don't get emotional for any tool you use. An iPhone - I'm sorry to disappoint you - is just a phone. No magic. No "think different". "But it's evil!", the ether says, "it's not open source". Well, Android just exists because Google needed to rapidly develop a mobile platform. It's simply part of their business. There is no moral behind that. Google is a yet another company just like Microsoft or Apple.

My MacBook serves me as a solid tool, but if something "better" comes around, I will happily kick it out. I've ditched Firefox after five years just because Chrome is faster and I will get rid of Chrome when I find a worthy successor.
Vim is _quite good_ in my opinion but if there's a faster way to do things I'm not afraid to dump it. Instead get your hands dirty and fix the problems or craft something new.
